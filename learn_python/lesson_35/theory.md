1. Три составляющие, благодаря которым наше Джанго-приложение работает и отвечает на запросы пользователя. Перечисли их,
а потом вкратце пробегись по каждой из составляющих
2. Где хранятся все настройки нашего Django-проекта
3. С помощью какой функции осуществляется рендер шаблона и вывод его в качестве ответа пользователю
4. Что такое manage.py?
5. С помощью какой команды можно создать базовую структуру проекта
6. С помощью какой команды можно запустить сервер в режиме разработки


### Приложения

Любой веб-проект достаточно быстро перестает помещаться в рамках одного пакета: становится слишком много views и 
urlpatterns. Чтобы контролировать процесс роста, мы можем использовать стандартный для Python прием декомпозиции — 
превращение модуля в пакет с подмодулями.

В случае `views.py` это даже сработает. Но разделить на части правила роутинга — элементы списка `urlpatterns` в urls.py — 
будет уже сложновато. Придется вручную собирать список правил из отдельных кусочков.


Django позволяет не придумывать свои способы управления сложностью. В фреймворке уже есть готовый паттерн — 
приложения или applications.


Каждое приложение представляет собой пакет с модулями, который включает в себя модуль описания моделей и вьюх. Также в него
часто входят свои шаблоны и свои же `urlpatterns`. Приложения часто выглядят как миниатюрные, но самостоятельные 
веб-приложения. Эта самостоятельность помогает реализовывать переиспользуемые приложения, которые решают типовые задачи.

Сам фреймворк Django предоставляет набор таких приложений-кирпичиков, которые помогают быстро заложить фундамент проекта.

### Создаем первое приложение


У нас уже есть одно приложение. Самый первый пакет, который мы создаем при запуске `django-admin startproject`, может и 
не быть приложением. Его задача: описать точки входа в веб-приложение. В этом пакете задаются настройки всего приложения
и корневые `urlpatterns`.

Мы сделали пакет приложением, когда добавили его в settings.INSTALLED_APPS.

Этот список содержит перечень всех Django applications, которые подключены к текущему проекту. Многие механизмы 
фреймворка обращаются к этому перечню во время своей работы. Так встроенный загрузчик шаблонов (Template Loader) ищет
их в поддиректориях с именем templates во всех подключенных приложениях. Для этого мы подключили в роли приложения — 
чтобы загрузчик шаблонов нашел наш первый шаблон.

Чтобы создать новое приложение, нужно перейти в директорию пакета и выполнить `django-admin startapp <app_name>`.

Здесь модуль `models.py` и пакет `migrations` относятся к слою хранения. Они пока нас не интересуют. `tests.py` 
описывает тесты, `admin.py` описывает админку — на это мы тоже пока не обращаем внимание. А вот `views.py` нам пригодится.

Чтобы закончить создание болванки приложения, остается задать его имя в файле `apps.py` и подключить в `settings.INSTALLED_APPS`. 
Для этого в качестве имени мы указываем полный путь к приложению:

Для этого в качестве имени в файле apps мы указываем имя нашего приложения:

    class SomeNameConfig(AppConfig):
        ...
        name = 'some_name'  # <- изменяем эту строчку

Далее добавляем имя приложения в список:

    INSTALLED_APPS = [
        ...
        'some_name',  
        ...
    ]

### Добавляем маршрутизацию

По умолчанию в приложении не генерируется модуль `urls.py`. Дело в том, что приложение может и не быть настолько большим,
чтобы потребовался отдельный набор правил маршрутизации. Такие небольшие приложения прописывают в `urls.py` уровнем выше.
Но мы будем делать большое приложение, поэтому смело создаем файл `project_name/app_name/urls.py` следующего вида

    from django.urls import path

    from project_name.app_name import views

    urlpatterns = [
        path('', views.index),
    ]


Пока все максимально похоже на корневой `urls.py` — мы снова связали пустой путь с вьюхой `views.index`, но уже из этого приложения.

Теперь нужно связать urlpatterns приложения с `urlpatterns` проекта. Модифицируем `project_name/urls.py`:


    from django.urls import path, include  # <- добавлен include

    from project_name import views

    urlpatterns = [
        path('', views.index),
        path('some_path/', include('project_name.app_name.urls')),  # <- новая строчка
        path('admin/', admin.site.urls),
    ]

С этого момента все пути, которые начинаются с "some_path/", будут перенаправляться в project_name.app_name.urls. 
В приложении у нас уже приписана `view.index`, которая связана с путем ''. Это означает, что запрос по пути `some_path/`
без каких либо продолжений будет направлен в `project_name.app_name.views.index`.

Мы встроили приложение в проект по префиксу пути. Переиспользуемые приложения обычно встраиваются именно таким образом.
Префикс `some_path/` задается вне встраиваемого приложения, поэтому приложение может быть встроено в любой проект по
любому префиксу. И правила маршрутизации этого приложения не будут конфликтовать с правилами проекта и других приложений.
