### Модули

В реальной разработке в проекте зачастую сотни тысяч, а иногда и миллионы строк кода. 
Само собой разумеется, что этот код нужно каким-то образом структурировать. Ведь подобный масштаб проекта невозможно было бы поддерживать в одном файле.

Для этого в Python разработчики разбивают код по файлам, так называемым модулям. Файл и модуль можно воспринимать как равнозначные вещи.
Именовать модули принято также, как функции и переменные - в snake_case стиле. 

Чтобы в рабочем модуле использовать код из других модулей, существуют импорты.

Есть три способа импортировать нужную тебе функцию/переменную из другого модуля:

1) Импорт модуля целиком
2) Импорт отдельной функциональности модуля путям явного указания импортируемых функций.
3) Импорт всего содержимого модуля.

Синтаксис импорта выглядит так:

`from <название пакета> import <название модуля>`

Либо, если модуль, который тебе нужно импортировать, находится в рабочем каталоге, то:

`import <название модуля>`

Перейдем сразу к примерам.

Первый и второй способ всегда более предпочтительны, так как не засоряют область видимости ненужными функциями и определениями.


#### Импорт всего содержимого модуля

Это самый нежелательный вариант импорта, так как при его использовании возникают проблемы с читаемостью кода, а также может происходить неявное перекрытие имен.

В код он выглядит так:

`from <название модуля> import *`

В таком случае из модуля неявно будет импортированы все функции, переменные, классы и так далее. 

    from some_module import *
    from another_module import *

В примере выше из модуля some_module неявно импортируются все объекты. Обращение к этим объектам происходит без явного указания модуля, из которого
они были импортированы. К тому же, если в обоих импортированных модулях есть функция/переменная с одинаковым именем, то переменная из модуля, который был импортирован позже
переопределит переменную, которая была импортирована раньше.

Пример

Практика №1, №2, №3


### Кортежи

До этого времени мы встречались только с простыми типами данных? Какими?


Сегодня мы познакомимся с первым составным типом данных - кортежем.

Составные типы данных могут включать в себя другие типы данные.

На примере кортежа это выглядит так:

some_tuple = (1, 'string', True, 2, 'hello')

При этом кортеж может состоять из одного элемента:

tuple = (42,)

Или быть пустым:

empty_tuple = ()

Одна из особенностей кортежа в том, что он неизменяем. То есть кортеж после создания изменить уже нельзя, по аналогии со строкой, числом, или булевым типами данных.

    name_and_age = ('Bob', 42)
    name_and_age[0] = 'Alice'

    # Traceback (most recent call last)
    # TypeError: 'tuple' object does not support item assignment
    name_and_age # ('Bob', 42)

При попытке изменить кортеж получим вот такую ошибку.

Кортежи могут быть полезны, когда нужно вернуть несколько значений сразу, например:

Функция, которая возвращает остаток от деления и результат деления нацело.

Пример.

Как извлекать значения по индексу?

Python для обработки всех коллекций предоставляет унифицированный интерфейс для обращения к отдельным их элементам. Как думаешь, как обратиться извлечь элемент кортежа.
Подсказка - кортеж, как и строка - это коллекция.

Помимо этого, есть удобный инструмент распаковки кортежа.

Пример

Практика