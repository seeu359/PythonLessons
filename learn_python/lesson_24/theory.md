### ООП

Большая часть кода, который мы до этого момента рассматривали, была написана в процедурном стиле: мы использовали 
переменные и код, их изменяющий. В этом курсе мы научимся писать объектный код. Объектно-ориентированное 
программирование (ООП) расширяет процедурное программирование, которое является ступенью развития императивного 
программирования.

### Классы, пространства имен, атрибуты

Ты уже знаком с понятием "пространства имен". Пространство имен (namespace), это некая совокупность этих имен, в пределах которой каждое имя уникально. 
При этом разные пространства имен могут содержать одно и то же имя, но в разных пространствах это имя может быть связано с разными сущностями

Уже знакомым тебе примером пространств имен является модуль. В пределах модуля вы не сможете сделать два объявления 
с одинаковыми именами: то, что будет сделано позже, просто поменяет значение имени. Зато разные модули могут содержать 
элементы с одним и тем же именем.

Каждый класс также является отдельным пространством имен — имен атрибутов класса. Атрибут, это то же самое определение.
В момент определения класса определяются и его атрибуты.


### Объявление класса

Класс может быть объявлен в любом месте кода. Ведь объявление класса, это всего лишь создание специального объекта. 
Да, классы — тоже объекты! Однако чаще всего классы объявляются на верхнем уровне модулей и таким образом оказываются 
созданы при первом импорте модуля (я расскажу об этом позже).

Объявление минимального класса выглядит так:

`Пример 1`

В данном случае ключевое слово pass позволяет описать пустой блок (это ключевое слово можно использовать в любом месте, 
где требуется блок — в функциях, циклах, условиях!).

После выполнения этого кода в модуле появляется новый атрибут "ExampleClass", где "ExampleClass" это и имя атрибута модуля, и имя 
объявленного класса. С этого момента объект класса можно использовать как любой другой — передавать в функции, 
сохранять в переменные, помещать в списки и словари.

Класс `ExampleClass` сейчас не содержит ни одного атрибута. Но это уже полноценный класс. По этому "шаблону" можно создавать 
экземпляры, о чем мы поговорим в следующем уроке. Но давай все же поместим в класс хоть что-то, а заодно посмотрим, как 
выглядит созданный класс снаружи:

`Пример 1`

Эта версия класса C уже содержит два атрибута — a и b. Эти атрибуты похожи на переменные в модулях, но их видимость 
ограничена классом C.


### Именование классов

В Python классы принято называть в стиле CamelCase. Это позволяет визуально отделить классы от переменных, функций, констант. 
Но будьте готовы к тому, что иногда имя у класса может выглядеть, как имя функции. Далеко за примером ходить не нужно:


### Инстанцирование классов и экземпляры—

Класс, как мы уже увидели, может хранить данные. Но типичный класс присутствует в программе в единственном экземпляре. 
Поэтому сам по себе класс не очень полезен, ведь хранить определения можно и в модулях. Весь смысл использования классов 
заключается в их инстанцировании.

Инстанцированием (instantiation) называют процесс (акт) создания на основе класса экземпляра (instance) — такого объекта, 
который получает доступ ко всему содержимому класса, но при этом обладает и способностью хранить собственные данные. 
При этом, имея объект, всегда можно узнать, экземпляром какого класса он является.

Давайте объявим класс и создадим пару экземпляров, а заодно и познакомимся с синтаксисом инстанцирования классов:

`Пример 2`

Что мы можем увидеть в этом примере? Первое, что бросается в глаза, это вызов класса как функции: `Person()`. Сходство 
это — не только внешнее. В Python инстанцирование фактически и является вызовом некоторой функции, которая возвращает 
новый экземпляр класса.

Также стоит обратить внимание на то, что все экземпляры являются отдельными объектами, поэтому оператор is дает False 
как при соотнесении экземпляров между собой, так и при соотнесении любого экземпляра с объектом класса (bob, alice и Person — три самостоятельных объекта).

### Атрибут __dict__

Стоит прямо сейчас заглянуть "под капот" объектной системы Python, чтобы вы в дальнейшем могли исследовать объекты самостоятельно. 
Это и интересно, и полезно — как при обучении, так и при отладке объектного кода.

Итак, внутри каждого объекта Python хранит… словарь! Имена атрибутов в пространствах имен выступают ключами этого словаря, 
а значения являются ссылками на другие объекты. Словарь этот всегда называется __dict__ и тоже является атрибутом. 
Обращаясь к этому словарю, ты можешь получить доступ к значениям атрибутов:

`Пример 3`

    Практика 1, 2, 3, 4

### Методы класса

1. Что такое методы? Встречались ли мы с методами до этого?

Давай же объявим класс и метод в нем:

`Пример 4`


Здесь `Math.add` — обычная функция, о чем нам и говорит интерпретатор. Но сами по себе обычные функции, помещенные в 
класс не так интересны: те же функции мы можем группировать и в модулях. Более того, обычные функции стоит объявлять именно в модулях.

Методы же нужны для того, чтобы работать с данными объектов класса. Но для этого методы должны быть связаны (bound).

### Связанные методы

Вспомни, метод list.append (list — это класс, помним и это) модифицирует именно объект списка. Посмотрим на этот метод поближе:

    l = []
    list.append(l, 42)
    l  # [42]

Я вызвал метод класса, как обычную функцию и передал первым аргументом объект списка. Метод изменил переданный список. 
Но ведь раньше мы вызывали этот метод в виде `l.append(42)`! Так вот l.append это связанная версия метода list.append: 
метод связан с конкретным объектом списка и знает, что именно его он должен модифицировать!

`Пример 5`


Именно через аргумент self метод получает доступ к атрибутам связанного объекта (и его класса, конечно же).

Практика 5, 6, 7, 8
