### Обход строк

С помощью циклов можно работать не только с числами, но и обходить строки, ведь мы можем обращаться к символу строки по его индексу.
Ниже пример функции, которая обходит строку, и поочередно выводит каждый символ этой строки.

    def print_name_by_symbol(name):
    i = 0
    # Такая проверка будет выполняться до конца строки,
    # включая последний символ. Его индекс `length - 1`.
    while i < len(name):
        # Обращаемся к символу по индексу
        print(name[i])
        i += 1

    name = 'Arya'
    print_name_by_symbol(name)

Самое главное поставить правильное условие в цикле. В данном случае оно может быть таким -  `i < len(name)`,  или таким -  `i <= len(name)`.
Что будет если условие в цикле будет неверным? - например таким `i <= len(name)`

`Практика №1, №2`

### Условия внутри цикла

Эта тема не новая для нас, но сказать о ней стоит. В теле цикла так же как и в любом другом месте кода, можно определять условные конструкции.

Представь себе функцию, которая находит количество вхождений символов в строку. Как бы ты ее реализовал?

Итак, в первом номере практики мы реализовали функцию, которая извлекает длину извлекаемой подстроки. Есть ли у нее недостатки, как ты думаешь?

В подобных случаях всегда стоит думать на перед и продумывать пограничные случаи использования твоей функции. В идеале создать такую функцию, которая на любой
набор входных данных будет отдавать предсказуемый результат и не падать с ошибками.

---

Работа с циклом while обычно сводится к двум ситуациям:

* Агрегация. Накопление результата во время итераций и работа с ним после цикла. Переворот строки относится к такому варианту
* Выполнение цикла до достижения необходимого результата и выход. Например, задача поиска простых чисел — которые делятся без остатка только на себя и на единицу

Рассмотрим алгоритм проверки простоты числа. Будем делить искомое число x на все числа из диапазона от двух до x - 1 и смотреть остаток. 
Если в этом диапазоне не найден делитель, который делит число x без остатка, значит, перед нами простое число.

В этом случае достаточно проверять числа не до x - 1, а до половины числа. Например, 11 не делится на 2, 3, 4, 5. 
Но и дальше не будет делиться на числа больше своей половины. Значит, можно оптимизировать алгоритм и проверять деление только до x / 2:


    def is_prime(number):
        if number < 2:
            return False
    
        divider = 2
    
        while divider <= number / 2:
            if number % divider == 0:
                return False
    
            divider += 1
    
        return True

    print(is_prime(1))  # => False
    print(is_prime(2))  # => True
    print(is_prime(3))  # => True
    print(is_prime(4))  # => False

Представим, что по алгоритму последовательного деления на числа до x / 2 нашлось одно, которое делит без остатка. Значит, переданный аргумент — не простое число, и дальнейшие вычисления не имеют смысла. В этом месте стоит возврат False.

Если цикл отработал целиком, и не нашлось число, которое делит без остатка, значит, число — простое.

`Практика №3`


### Цикл for

Цикл while - достаточно мощный инструмент, с помощью него можно обойти любую последовательность, решить любую повторяющуюся задачу.
Но его отличает многословность. Что нужно, чтобы цикл while отработал корректно?

В Python есть прекрасный инструмент - цикл for. Его используют настолько часто, насколько это только возможно. Цикл for очень мощный инструмент.
Основное его отличие от цикла while - ему не нужно условие для остановки. Коллекции, которые перебираются с помощью циклов конечны.
Цикл for всегда сам знает, когда ему нужно остановится.

Итак, цикл for содержит: 

    for symbol in string:
        print(symbol)
    

`for` - оператор, который указывает интерпретатору о начале цикла. 
`symbol` - временная переменная, которая доступна только в теле цикла. В ней хранится текущее значение строки или другой коллекции, которое будет обработано на конкретной итерации.
`in` - оператор, который указывает, по какой коллекции будем итерироваться
`string` - коллекция, которую мы обходим в цикле.
И далее тело цикла.

Пример:

    text = 'code'
    for symbol in text:
        print(symbol)
    
    # => c
    # => o
    # => d
    # => e

Итак, еще раз `for <временная переменная> in <коллекция>:`

Посмотрим, как реализовать функцию переворота строки через цикл for:

    def reverse_string(text):
    # Начальное значение
    result = ''
    # char - переменная, в которую записывается текущий символ
    for char in text:
        # Соединяем в обратном порядке
        result = char + result
    # Цикл заканчивается, когда пройдена вся строка
    return result

    reverse_string('go!')  # => '!og'

Цикл `for` очень важный элемент в языке Python. Как я уже сказал, его используют очень часто, по этому его нужно знать и понимать очень хорошо.

`Практика №4, №5, №6`
