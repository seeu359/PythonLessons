### Повторение
1. Что такое декораторы и зачем они нужны?
2. Как декораторы связаны с замыканиями?



### Генераторы списков

В повседневной жизни разработчика часто встречается код, работающий с последовательностями. Это связано с тем, 
что итераторы встроены в Python и тесно интегрированы в стандартную библиотеку.

Итераторы и операции над ними обычно собираются в конвейеры для данных. Лишь в конце каждого конвейера стоит reduce() 
или другой потребитель элементов, не передающий элементы дальше.

Большинство таких конвейеров состоит из двух видов операций:

1. Преобразование отдельных элементов. Эту задачу выполняет функция map(). Она преобразует весь поток с помощью другой 
функции, обрабатывающей отдельные элементы
2. Изменение состава элементов, то есть фильтрация или размножение. Фильтровать данные умеет filter(). А уже map() в 
паре с chain() из модуля itertools превращают каждый элемент в несколько, не меняя при этом уровень вложенности

Для примера представим, что мы хотим получить список чисел вида [0, 0, 2, 2, 4, 4...] — то есть по две копии 
возрастающих четных чисел. Напишем подходящий конвейер:

**Пример 1.** 

Минусы такого кода:

1. Если готовых функций над элементами или предикатов нет, то их либо приходится заранее объявлять, либо использовать 
lambda.
2. Lambda смотрятся очень громоздко, читаемость кода постепенно падает.


Для работы с конвейерами данных у Python'а есть прекрасное идиоматичное решение - `генераторы списков`. На самом деле одними списками
дело не ограничивается - подобным образом можно генерировать генераторные выражения, словари и множества.

    [x for num in range(20) for x in [num, num] if num % 2 == 0]


На первый взгляд выглядит достаточно непонятно, но к такому синтаксису можно привыкнуть. Можно немного отформатировать
выражение, сделав его похожим на вложенный цикл:

    [x
        for num in range(20)
            for x in [num, num]
                if num % 2 == 0
    ]

Выражения вида `[… for … in …]` называются генераторами списков. Рассмотрим составляющие нового синтаксиса.

Генератор списков описывается так:

    [ВЫРАЖЕНИЕ for ПЕРЕМЕННАЯ in ИСТОЧНИК if УСЛОВИЕ]

Рассмотрим этот шаблон подробнее:

`ВЫРАЖЕНИЕ` может использовать `ПЕРЕМЕННУЮ` и вычисляется в элемент будущего списка

`ПЕРЕМЕННАЯ` — имя, с которым поочередно связываются элементы `ИСТОЧНИКА`

`ИСТОЧНИК` — любой итератор или итерируемый объект

`УСЛОВИЕ` — выражение, которое использует `ПЕРЕМЕННУЮ`, вычисляемую на каждой итерации

Если условие оказывается ложным, то вычисление выражения для текущей итерации пропускается — в итоговый список новый 
элемент не добавится. Очень похоже на `filter`

**Пример 2.**
