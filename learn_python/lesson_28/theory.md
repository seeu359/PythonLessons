### Исключения

Любая программа может выполняться с ошибками. Часть ошибок связана с самим кодом. А другая часть связана с ситуациями,
которые возникают довольно редко, но означают, что дальнейшее выполнение программы невозможно, если возникшую проблему
никак не решить. Такие ситуации исключительны. Поэтому и механизм языка, предназначенный для работы с исключительными 
ситуациями, называется системой исключений (exceptions).

Пример исключительной ситуации: ошибка `IndexError`. Эту ошибку ты видишь, когда обращаешься к строке, списку, 
кортежу по индексу, который выходит за границы коллекции. Как правило, с коллекциями ты работаешь с помощью цикла for, 
или же не забываете следить за тем, чтобы индекс не достигал длины списка. А значит ситуация выхода индекса за 
допустимые границы — исключительная!

Когда ты открываешь файл на запись, а место на диске внезапно заканчивается или у вас не оказывается прав на запись
в этот файл — все это тоже исключительные ситуации.

При этом ты не можешь продолжать выполнять программу, если в файл не получается записать или элемента в списке по
вычисленному индексу не окажется. Выполнение должно прерваться максимально быстро, чтобы программа не успела ухудшить 
ситуацию.

Возбуждение (raising) исключения в коде похоже на return, только на его глобальную версию, завершающую все функции 
в порядке, обратном тому, в котором они вызывались. Если исключение будет возбуждено, но не будет перехвачено, 
то есть как-то обработано, вся программа так и завершится и ты увидишь распечатку трейсбэка (traceback). 
Там-то и будет отображена та самая ошибка IndexError (или какая-то другая).

### Иерархия исключений

Исключения в современном языке программирования с богатой системной библиотекой могут быть самыми разными и 
представлены во множестве. Однако почти всегда исключения объединяются в иерархию исключений. Так все "ошибка 
ввода-вывода"/IOError или ошибка "файл не найден"/`FileNotFoundError` наследуются от исключения `OSError` 
("ошибки взаимодействия с Операционной Системой"), которое наследуется от `Exception` ("просто некое исключение"). 
`IndexError` и `KeyError` ("ключ (словаря) не найден") являются потомками `LookupError` ("ошибка поиска чего-то"), 
которое является потомком `Exception`.



Иерархия исключений, таким образом, представляет собой дерево, корнем которого является `BaseException`, 
стволом — `Exception`, а дальше происходит ветвление на виды исключений, а затем — на конкретные исключения.

Зачем же нужно было придумывать эту самую иерархию исключений? Чтобы можно было "ловить" исключения как по одному 
(ловить `IndexError`), так и перехватывать целые группы (`OSError`).

### Синтаксис исключений

Вот так выглядит возбуждение исключения:

`Пример 1`

Ключевое слово raise принимает в качестве аргумента экземпляр какого-либо класса, являющегося потомком BaseException. 
Большинство исключений принимают в качестве параметра строковое сообщение, описывающее конкретную ситуацию.

А так выглядит перехват исключений:

`Пример 2`

`try`: начинает блок, при выполнении которого могут возникать исключения. Следом идут одна или несколько веток `except`, 
которые описывают базовый класс исключений, которые будут перехватываться. Если возникшее исключение подошло — класс 
исключения оказался потомком от указанного базового класса или самим указанным классом, то будет выполнен код 
обработчика. В данном примере вместо ошибки мы видим печать сообщения.

Важно помнить, что если у тебя указано несколько веток except, то первыми нужно указывать наиболее конкретные ветки. 
Иначе вы можете оказаться в ситуации вроде этой:

`Пример 3`

Здесь ветка `except Exception`: отлавливает вообще все исключения, ведь любое конкретное исключение косвенно будет 
экземпляром `Exception`! Увы, вторая ветка `except` не имеет шанса хоть раз быть выполненной :(

Отметьте, что во второй ветке мы указали кортеж, содержащий несколько классов исключений. Таким образом можно указать
обработчик, который будет перехватывать несколько видов исключений.

### Ветка finally

Иногда не нужно отлавливать исключения в конкретном блоке кода. Например, вы хотите поймать исключение где-то выше или 
вообще ничего не ловить. Однако просто так прерывать выполнение кода нельзя, потому что требуется некое действие 
вроде закрытия открытого файла. В таких случаях применяют ветку `finally`:

`Пример 4`

В этом коде файл будет закрыт (`f.close()`) в любом случае, вне зависимости от того, произошла ошибка или нет. 
Если ошибка все же произошла, то сразу после блока finally выполнение кода будет прервано и исключение "всплывет" 
выше, но хотя бы по поводу незакрытого файла можно будет не волноваться!

Ветка finally может использоваться вместе с ветками except, но должна идти самой последней.

