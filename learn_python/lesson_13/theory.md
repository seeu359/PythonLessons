### Defaultdict - подвид словарей

Представь ситуацию: тебе нужно хранить в словаре в качестве значений списки или любые другие изменяемые данные. 
У вас есть ключ и элемент для добавления в список-значение, но сам ключ в словаре может быть не представлен. 
В таком случае придется писать подобный код:

    if key not in dictionary:
        dictionary[key] = []  # инициализируем список
    dictionary[key].append(value)

Подобная ситуация встречается не так уж и редко. Это понимали и авторы стандартной библиотеки Python и дали словарю метод setdefault. 
Именно этот метод мы рассмотрим подробнее в этом уроке.

Пример.


### Тип defaultdict

Во встроенном в Python модуле collections присутствует коллекция defaultdict.
Во всех отношениях defaultdict — это обычный словарь. При этом у него есть одно уникальное свойство: 
там, где обычный словарь ругается на отсутствие ключа, defaultdict сам возвращает значение по умолчанию. 
Давай рассмотрим пример:

    from collections import defaultdict

    d = defaultdict(int)
    d['a'] += 5
    d['b'] = d['c'] + 10
    d  # defaultdict(<class 'int'>, {'a': 5, 'c': 0, 'b': 10})

При создании словаря мы указали в качестве аргумента функцию int. Если эту функцию вызвать без аргументов, то она вернет 0. 
Именно этот вызов внутри словаря d и происходит всякий раз, когда нужно получить 
значение для несуществующего ключа.

В примере выше `d['a'] += 5` дает 5, потому что этот код работает так:

Сначала для ключа 'a' создается начальное значение — делается вызов `int()`и получается 0
Уже потом к нему прибавляется 5
В строчке `d['b'] = d['c'] + 10` создаются значения для ключей 'b' и 'c'. Затем уже по ключу 'b' записывается сумма 0 + 10.


### Отличия defaultdict от обычного словаря с setdefault


Зачем вообще использовать setdefault? Например, он помогает инициализировать разные значения по разным ключам. 
Значение по умолчанию передается каждый раз, поэтому мы можем хранить по разным ключам даже разные типы данных.

С defaultdict у нас нет контроля над тем, какие значения по каким ключам класть. 
Функция-инициализатор вызывается каждый раз одна и та же — ключ в нее не передается.

