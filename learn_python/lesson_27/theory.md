### Наследование

Все классы, которые мы рассматривали до этого, создавались "с нуля". И до тех пор, пока описываемые классами сущности 
мало похожи друг на друга, создание абсолютно новых классов работает отлично. Но что делать, если мы хотим, чтобы 
пара классов содержала один и тот же метод — не одноименный, а именно копию?

Конечно же, мы можем при объявлении класса вместо объявления метода по месту поместить в атрибут ссылку на существующую 
функцию. И это даже сработает! Но когда таковых методов станет несколько, уследить за тем, что и куда копируется, 
станет очень сложно. К счастью, есть способ лучше!

Языки, реализующие инструментарий для объектно ориентированного программирования, включая использование классов,
как правило предоставляют и механизм наследования. Python — один из таких языков. Поэтому классы в Python можно наследовать.

Когда один класс становится наследником другого, то все атрибуты класса-предка (надкласса, superclass) становятся 
доступны классу-потомку (подклассу, subclass) — наследуются (достаются в наследство).


### Что дает наследование

Наследование позволяет выделить общее для нескольких классов поведение и вынести его в отдельную сущность. 
То есть наследование является средством переиспользования кода (code reuse) — использования существующего кода для 
решения новых задач!

Наследование позволяет получить новый класс, немного отличающийся от старого. При этом нам не нужно иметь доступ 
к коду исходного класса, а значит с помощью наследования мы можем адаптировать (использовать повторно) под наши 
задачи в том числе и чужие классы!

Как обычно, рассмотрим `пример`


Метод `dec` — метод класса `NonDecreasingCounter`, связанный с конкретным экземпляром NonDecreasingCounter. А вот `inc` — 
метод класса Counter, хоть и связанный с все тем же экземпляром класса-потомка.

Здесь вы можете увидеть сходство с взаимоотношениями между классом и его экземпляром: если экземпляр получает 
свой собственный атрибут, то этот атрибут заменяет атрибут класса. Точно так же объявления в классе-потомке заменяют 
собой атрибуты класса-предка, если имя используется то же самое — говорят, переопределяют (override).

И, как и в случае с объектом, который может использовать все содержимое класса и заменять только небольшую часть 
атрибутов (или добавлять новые!), так и потомок по-умолчанию получает все атрибуты предка, часть из которых может 
изменить.


### super()

Представим, что нас в целом устраивает класс Counter из предыдущего примера, но мы хотим при вызове inc увеличивать 
значение дважды. Мы могли бы заменить в потомке весь метод и прописать внутри нового метода `self.value += 2`. 
Но если бы позже что-то поменялось в исходном классе Counter, то эти изменения не коснулись бы нашего метода.

Тут нам на помощь приходит специальная функция `super`:

`Пример`

Вызов `super` здесь заменяет обращение к `self`. При этом вы фактически обращаетесь к "памяти предков": получаете ссылку 
на атрибут предка. Более того, в данном случае, `super().inc` - это связанный с текущим экземпляром метод, то есть 
полноценная "оригинальная версия" из класса-предка. Если бы вы вдруг решили вручную вызвать метод класса предка, 
то вам бы пришлось использовать его не связанную версию:

    class DoubleCounter(Counter):
        def inc(self):
            Counter.inc(self)  # явно обращаемся к методу класса предка
            Counter.inc(self)

