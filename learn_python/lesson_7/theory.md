### Повторение


Что такое модуль?
Что такое кортеж?
Дай краткое определение кортежа, как типа данных
Можно изменить существующий кортеж?


### Области видимости

Сразу рассмотрим практический пример:

Примеры 1


Хоть переменная age — это не аргумент функции generate(), ее все равно видно в теле функции. 
Так происходит, потому что переменную age определили ранее вызова функции, а интерпретатор 
Python читает файл сверху вниз. Это правило относится и к другим переменным.


Рассмотрим другой пример:

Пример 2


В данном случае результатом будет число 13. Внешнее значение age = 5 не влияет на код функции, 
потому что в теле функции определили свою переменную age — локальная переменная. Ее 
не видно за пределами функции.


В сухой теории, в Python есть 2 основных области видимости: глобальная и локальная

В примере 1 переменная age определена на уровне всего модуля. Таким образом, ее значение доступно во всех функциях,
где нет переменной с таким же именем. 

В примере 2 переменная age определена в локальном контексте(в функции) и по этому она доступна только в теле функции.


Порядок поиска имен такой. Сначала имя ищется в локальном контексте, если имя не найдено - происходит поиск в глобальном 
контексте.


### Списки

Список — структура данных, предназначенная для хранения упорядоченных наборов элементов. Слово 
«упорядоченные» в этом случае означает, что элементы структуры хранятся в том порядке, в котором они были добавлены.

Элементы списка индексированы, то есть имеют порядковый номер. Нумерация всегда начинается с нуля и всегда монотонна. Это значит, что у каждого последующего 
элемента индекс возрастает на единицу — такую нумерацию еще называют сквозной. При удалении элементов из начала или 
середины списка, а также при вставке элементов в середину, индексы пересчитываются и указанные выше свойства 
нумерации сохраняются.

Мы уже знаем, что при конкатенации двух строк получается новая строка(почему?), а при сложении чисел - новое число.

Помимо этого, мы на прошлом уроке рассмотрели кортежи - коллекцию, которую:

1. Можно разобрать на элементы. Как?
2. Не позволяют менять состав элементов, так как кортежи неизменяемая структура данных

Таким образом, все структура данных, которые мы рассмотрели ранее, были неизменяемыми.

Список - первая изменяемая структура.

Практика 1

### Создание и изменение списка

Для создания списков в Python, так же как и для кортежей, в Python есть особый синтаксис:

    some_lsit = [1, 'some_str', 5]
    numbers = [1, 2, 3]
    strings = ["foo", "bar"]
    booleans = [True, False]
    empty_list = []

Обрати внимание на именование. Так как список по своей семантике содержит коллекцию элементов, то все переменные названы в
множественном числе.

Так как список - изменяемый тип данных, то его можно менять по месту. То есть такие операции со списком как вставка элементов,
удаление, добавление в конец не создают новый список, а меняют текущий.

Вставка в список элементов производится с помощью специального спискового метода - append

Пример


Еще один похожий списковый метод - extend. Этот метод добавляет все элементы из списка-аргумента в свой список.

Пример

Практика 2, 3


### Модификация списков поэлементно

Список - это коллекция, так же как и строки. А значит к элементам списка можно обращаться по индексу.
Кроме того, так как список изменяемый объект, элементу по индексам также можно изменять.

    list = [1, 2, 'hello']
    list[0] = 10
    print(list) -> [10, 2, 'hello']
    list[-1] = 'string'
    print(list) -> [10, 2, 'string']

Также к списку применимы все функции, которые работают с коллекциями - например функция len вернет длину списка


### Методы pop и insert

Итак, получать и заменять элементы по одному мы умеем. Неплохо бы еще уметь удалять 
старые элементы и вставлять в середину списка новые. За это отвечают методы pop и insert соответственно. 
pop удаляет элемент по индексу.

Если не указать индекс, то удаляется последний элемент. При этом pop возвращает значение элемента, который удаляет:

    l = [1, 2, 3]
    l.pop()  # 3
    print(l)  # => [1, 2]
    l.pop(0)  # 1
    print(l)  # => [2]

А вот пример использования insert:

    l = [1, 2, 3]
    l.insert(1, 100)
    print(l)  # => [1, 100, 2, 3]
    l.insert(-1, 200)
    print(l)  # => [1, 100, 2, 200, 3]

insert всегда вставляет новый элемент перед элементом с указанным индексом относительно начала списка. 
При этом не важно, откуда мы индекс отсчитывали — от начала или от конца. И insert(-1, ..) вставляет элемент именно 
перед последним элементом.

Интересно, что l.insert(len(l), x) добавит элемент x в конец списка l, то есть сработает как l.append(x).

Практика 4, 5

