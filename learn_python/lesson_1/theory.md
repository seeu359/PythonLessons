### Изменяемость - неизменяемость данных

Иногда разработчикам нужно вернуть положительное значение числа, которое задали. Для этого в Python есть специальная функция.

Как пример, в Python есть такая функция, которая возвращает модуль числа, то есть возвращает положительно число

``number = -12``

``module = abs(number)``

В данном примере, функция abs вернет 12 и сохранит значение, которое вернула в переменную module.

``print(module) # 12``

Но чему равна переменная number?

``print(number) # ??``

Примитивные типы данных в Python неизменяемы(и не только они, но об этом чуть позже).
При каждой попытке изменить число или строку в существующей переменной мы получим ошибку.

Соответственно, любые строковые методы НЕ ИЗМЕНЯЮТ ТЕКУЩУЮ строку, а создают новую на основе старой, например:

``string = It's my string``

``string[0] = 'h'``

Что здесь происходит? 

При попытке запустить такую программу мы получим ошибку. 

Другой пример:

``string = 'Some STRING'``

Все просто, у нас есть переменная string, но нам не очень то нравится то, как она записана, и мы хотим использовать уже знакомый строковый метод lower. Для чего он? 

``lower_string = string.lower()``

``print(string) # ??``

``print(lower_string) # ??``

Как отработает каждый из принтов?

Итак, что нужно усвоить. Примитивные типы данных(строки, числа) встроены в сам язык Python. Примитивные типы данных в Python - неизменяемы. Нельзя изменить уже существующую строку или число. 
Какую-бы функцию ты не сделал, какой-бы метод классы не определил, любая попытка изменить строку или число будет приводить к ошибке вроде этой:

``Traceback (most recent call last):
  File "/Users/a.cheremushkin/PythonProjects/learn_python/lesson_1/examples.py", line 3, in <module>
    string[0] = 'q'
TypeError: 'str' object does not support item assignment``

Практика - №1


### Интерполяция

Мы с тобой знаем пока что один способ складывать строки - конкатенация:

``string1 = 'first string'``

``string2 = 'second string'``

``print(string1 + ', ' + string2) # first string, second string``

Конкатенация самый очевидный способ сложить строки, но наверно самый неудобный, особенно когда в строку 
нужно вставлять много пробелов, запятых и так далее. Что-то ты точно пропустишь, и придется долго и муторно вставлять пропущенный знак. 
Плюс такой код не всегда выглядит читаемо(почти всегда нечитаемо), а это очень важно!

Итак, что нам предлагает Python? Python предлагает прекрасную альтернативу - интерполяцию. Как она выглядит? Смотрим

``first_name = 'Joffrey'``

``greeting = 'Hello'``

``print(f'{greeting}, {first_name}!') # Hello, Joffrey!``

Буква f указывает на то, что мы создаем f-строку — шаблон, в который с помощью фигурных скобок подставляются значения переменных. На выходе получается обычная строка.

Рассмотрим такой пример:

``school = 'Hexlet'``

``what_is_it = f'{school} - online courses'``
``print(what_is_it)  # => Hexlet - online courses``

Почти во всех языках для объединения строк интерполяция предпочтительнее конкатенации. Строка при этом получается склеенная, и внутри нее хорошо просматриваются пробелы и другие символы.

Интерполяция помогает сделать код более понятным для разработчиков. Но это не единственная полезная альтернатива, о которой мы хотели рассказать. Далее разберемся, как объявлять многострочную строку и не использовать

### Вызов функции - выражение!

О чем вообще речь и что принимается за выражение? 

Выражение в программировании возвращает результат, который можно использовать. Например, такие математические операции, как 
сложение и вычитание, строковые операции, как конкатенация — все это выражения:

Что такое конкатенация?

Это конкатенация? ``'Кир' + 'илл'``

Итак, то, что возвращает результат - является выражением. Функция len возвращает результат своей работы?

Функции в Python, как я уже много раз говорил, очень часто(но не всегда) возвращают результат своей работы.

Является ли функция выражением?

Отсюда следует много интересных вещей, например мы можем использовать функцию в арифметической операции:

``name = 'python'``

``last_index = len(name) - 1``

``print(last_index)  # => 5``

Практика №3


### Новые строковые методы

Для примера будем использовать строку, сохраненную в переменную string

``string = 'some string'``

Метод replace - заменяет подстроку в исходной строке на переданную. Пример:

``new_string = string.replace('ing', 'str')``

``print(new_string) # some strstr``

Практика №4

Метод upper - противоположность метода lower(догадайся сам). Также похожий метод capitalize - возращает строку, где первая буква заглавная, а остальные нет

Пример:

``new_string = string.capitalize()``

``print(new_string) # Some string``

Практика №5

