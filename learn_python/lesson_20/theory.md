## Замыкания

Что такое замыкания

Замыкания — это функция, которая запоминает значения из своей внешней области видимости, даже если эта область уже не 
доступна. Она создается, когда функция объявляется, и продолжает запоминать значения переменных даже после того, как 
вызывающая функция завершит свою работу.

Замыкания — это инструмент, который позволяет сохранять значения и состояние между вызовами функций, создавать функции 
на лету и возвращать их из других функций.

Замыкание возникает, когда функция объявляется внутри другой функции и использует переменные из внешней функции. 
В этом случае внешняя функция создает замыкание, которое хранит ссылку на внешние переменные, используемые во 
внутренней функции. Замыкание позволяет внутренней функции получить доступ к этим переменным, даже если внешняя 
функция уже завершилась.

Рассмотри такой пример: **Пример 1**
    
    def outer_function(x):
        def inner_function(y):
            return x + y
        return inner_function

    closure = outer_function(10)
    print(closure(5)) 


### Еще раз про области видимости

Как ты помнишь, в Python есть 2 основные области видимости объектов:
1. Глобальная
2. Локальная

Объявляя функцию, и обращаясь в теле этой функции к какой-то переменной, функция сначала ищет эту переменную у себя в
локальной области видимости а уже затем, если переменная не был найдена, ищет в глобальной области видимости.

**Пример 2**


`nonlocal` — это ключевое слово в Python, которое используется при замыканиях во внутренней функции. 
Оно позволяет изменять значение переменных, определенных во внешней функции.

**Пример 3.** 


### Как работают замыкания

Замыкания - это всегда 2 функции: первая - внешняя, и вторая - внутренняя, вложенная в первую.

Если мы говорим про обычную, классическую функцию, то все ссылки на переменные, определенные в ее теле удаляются сборщиком мусора сразу
после того, как функция заканчивает свою работу. 

С замыканиями ситуация совсем иная. Мы как бы замыкаем во внутренней функции переменные,
которые определены во внешней функции, и даже после того, как внешняя функция завершит свою работу, во внутренней функции
по-прежнему останутся ссылки на объекты из внешней. Внутренняя функция как-бы замыкает в себе переменные и их значения из внешней функции.
И так как ссылки на объекты остаются во внутренней функции, мы можем их изменять от вызова к вызову функции.

**Пример 4.**

