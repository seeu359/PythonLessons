# Объяви в программе два класса Point и Rectangle. Объекты первого класса должны создаваться командой:
#
# pt = Point(x, y)
# где x, y - координаты точки на плоскости (целые или вещественные числа). При этом в объектах класса Point
# должны формироваться следующие локальные свойства:
#
# __x, __y - координаты точки на плоскости.
#
# и один геттер, возвращающий кортеж текущих координат __x, __y
#
# Объекты второго класса Rectangle (прямоугольник) должны создаваться командами:
#
# r1 = Rectangle(Point(x1, y1), Point(x2, y2))
# или
#
# r2 = Rectangle(2, 3, 4, 5)
# Здесь первая координата (x1, y1) - верхний левый угол, а вторая координата (x2, y2) - правый нижний. При этом, в
# объектах класса Rectangle (вне зависимости от способа их создания) должны формироваться следующие локальные свойства:
#
# __sp - объект класса Point с координатами x1, y1 (верхний левый угол);
# __ep - объект класса Point с координатами x2, y2 (нижний правый угол).
#
# Также в классе Rectangle должны быть реализованы следующие методы:
#
# set_coords(self, sp, ep) - изменение текущих координат, где sp, ep - объекты класса Point;
# get_coords(self) - возвращение кортежа из объектов класса Point с текущими координатами прямоугольника
# (ссылки на локальные свойства __sp и __ep);
# draw(self) - отображение в консоли сообщения: "Прямоугольник с координатами: (x1, y1) (x2, y2)".
# Здесь x1, y1, x2, y2 - соответствующие числовые значения координат.


...


# Тебе необходимо создать множество классов для валидации (проверки) корректности данных. Для этого можешь объявить в
# своем коде базовый класс Validator,
#
# обеспечивающий базовый функционал для проверки корректности данных. В частности, в этом классе нужно объявить
# следующий метод:
#
# def _is_valid(self, data): ...
# По задумке этот метод должен возвращать булево значение True, если данные (data) корректны и False - в
# противном случае.
#
# Так как базовый класс Validator - это общий класс для всех видов проверок, то метод _is_valid() будет просто
# возвращать True.

# Проверка корректности выполняется с помощью метода _is_valid(). После этого, в программе нужно объявить два
# дочерних класса:
#
# IntegerValidator - для проверки, что data - целое число в заданном диапазоне;
# FloatValidator - для проверки, что data - вещественное число в заданном диапазоне.
#
# Объекты этих классов предполагается создавать командами:
#
# integer_validator = IntegerValidator(min_value, max_value)
# float_validator = IntegerValidator(min_value, max_value)
# где min_value, max_value - допустимый диапазон чисел [min_value; max_value]

# Если в инициализатор переданы некорректные значения, возбуждать исключение ValueError.
#
# Также в этих классах нужно переопределить метод:
#
# def _is_valid(self, data): ...
# который бы возвращал True, если data является числом верного типа (либо int, либо float в зависимости от валидатора)
# и находится в заданном диапазоне [min_value; max_value]. Иначе, возвращается False.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# integer_validator = IntegerValidator(-10, 10)
# float_validator = FloatValidator(-1, 1)
# res1 = integer_validator(10)  # исключение не генерируется (проверка проходит)
# res2 = float_validator(10)    # исключение ValueError

...


#  С помощью множественного наследования удобно описывать принадлежность объектов к нескольким разным группам.
#  Выполним такой пример (Иерархия чисел.png)

# Определи в программе классы в соответствии с их иерархией, представленной на рисунке выше:
#
# Digit, Integer, Float, Positive, Negative
#
# Каждый объект этих классов должен создаваться однотипной командой вида:
#
# obj = Имя_класса(value)

# где value - числовое значение. В каждом классе следует делать свою проверку на корректность значения value:
#
# - в классе Digit: value - любое число;
# - в классе Integer: value - целое число;
# - в классе Float: value - вещественное число;
# - в классе Positive: value - положительное число;
# - в классе Negative: value - отрицательное число.

# Если проверка не проходит, то генерируется исключение командой:
#
# raise TypeError('значение не соответствует типу объекта')
# После этого объявите следующие дочерние классы:
#
# PrimeNumber - простые числа; наследуется от классов Integer и Positive;
# FloatPositive - наследуется от классов Float и Positive.


...

# Часто множественное наследование используют для наполнения дочернего класса определенным функционалом.
# То есть, с указанием каждого нового базового класса, дочерний класс приобретает все больше и больше возможностей.
# И, наоборот, убирая часть базовых классов, дочерний класс теряет соответствующую часть функционала.
#
# Например, паттерн миксинов активно используют в популярном фреймворке Django.  В частности, когда нужно указать
# дочернему классу, какие запросы от клиента он должен обрабатывать (запросы типа GET, POST, PUT, DELETE и т.п.).
# В качестве примера реализуем эту идею в очень упрощенном виде, но сохраняя суть паттерна миксинов.
#
# Предположим, что в программе уже существует следующий набор классов:
#
# class RetriveMixin:
#     def get(self, request):
#         return "GET: " + request.get('url')
#
#
# class CreateMixin:
#     def post(self, request):
#         return "POST: " + request.get('url')
#
#
# class UpdateMixin:
#     def put(self, request):
#         return "PUT: " + request.get('url')
# Здесь в каждом классе выполняется имитация обработки запросов. За GET-запрос отвечает метод get() класса
# RetriveMixin, за POST-запрос - метод post() класса CreateMixin, за PUT-запрос - метод put() класса UpdateMixin.
#
# Далее, тебе нужно объявить класс с именем GeneralView, в котором следует указать атрибут (на уровне класса):
#
# allowed_methods = ('GET', 'POST', 'PUT', 'DELETE')
# для перечня разрешенных запросов. А также объявить метод render_request со следующей сигнатурой:
#
# def render_request(self, request): ...
#
# Здесь request - это словарь (объект запроса), в котором обязательно должны быть два ключа:
#
# 'url' - адрес для обработки запроса;
# 'method' - метод запроса: 'GET', 'POST', 'PUT', 'DELETE' и т. д.
#
# В методе render_request() нужно сначала проверить, является ли указанный запрос в словаре request разрешенным
# (присутствует в списке allowed_methods). И если это не так, то генерировать исключение командой:
#
# raise TypeError(f"Метод {request.get('method')} не разрешен.")
# Иначе, вызвать метод по его имени:
#
# method_request = request.get('method').lower()  # имя метода, малыми буквами
# Подсказка: чтобы получить ссылку на метод с именем method_request, воспользуйтесь магическим методом __getattribute__().
#
# Для использования полученных классов, в программе объявляется следующий дочерний класс:
#
# class DetailView(RetriveMixin, GeneralView):
#     allowed_methods = ('GET', 'PUT', )
# Воспользоваться им можно, например, следующим образом (эти строчки в программе не писать):
#
# view = DetailView()
# html = view.render_request({'url': 'https://stepik.org/course/116336/', 'method': 'GET'})
# print(html)   # GET: https://stepik.org/course/116336/
# Если в запросе указать другой метод:
#
# html = view.render_request({'url': 'https://stepik.org/course/116336/', 'method': 'PUT'})
# то естественным образом возникнет исключение (реализовывать в программе не нужно, это уже встроено в сам язык Python):
#
# AttributeError: 'DetailView' object has no attribute 'put'
#
# так как дочерний класс DetailView не имеет метода put. Поправить это можно, если указать соответствующий базовый класс:
#
# class DetailView(RetriveMixin, UpdateMixin, GeneralView):
#     allowed_methods = ('GET', 'PUT', )
# Теперь, при выполнении команд:
#
# view = DetailView()
# html = view.render_request({'url': 'https://stepik.org/course/116336/', 'method': 'PUT'})
# print(html)
# будет выведено:
#
# PUT: https://stepik.org/course/116336/
#
# Это и есть принцип работы паттерна миксинов.

...


class RetriveMixin:
    def get(self, request):
        return "GET: " + request.get('url')


class CreateMixin:
    def post(self, request):
        return "POST: " + request.get('url')


class UpdateMixin:
    def put(self, request):
        return "PUT: " + request.get('url')


class A(UpdateMixin):

    def some(self, request):
        method = self.__getattribute__('put')
        method(request)