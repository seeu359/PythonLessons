1. Что такое приложения в Django? Для чего их создавать, ведь можно обойтись и без них.
2. Для чего нужна функция render?
3. Для нужна функция include? 


### Django ORM

Практически любое веб-приложение так или иначе работает с базой данных. При этом с системой управления базами данных 
(СУБД) приложение общается универсальным способом, например, посредством языка SQL.

Программисту чаще всего хочется иметь некую абстракцию, которая позволяет большую часть времени работать с привычными 
сущностями языка. Такой абстракцией является ORM.

### ORM 

ORM (Object-Relational Mapping) — отображение сущностей предметной области и их взаимосвязей в объекты, удобные для 
использования программистом.

Разные ORM по-разному подходят к тому, насколько нужно изолировать пользователя от конкретного хранилища. 
Некоторые полностью скрывают всю работу с базой данных. В этом случае мы пользуемся объектами, 
изменяем их состояние, а ORM неявно синхронизирует состояние объектов и сущностей в хранилище.

Другие ORM только оборачивают сущности базы данных в структуры языка, но все запросы нужно писать 
вручную. Это два разных полюса, каждый со своими плюсами и минусами. Авторы Django решили остаться 
где-то посередине.

Если использовать Django ORM, можно работать с объектами и выполнять вручную их загрузку и сохранение.
Однако для этого можно использовать привычные средства языка: итерацию, вызов методов.

Django же обеспечивает правильную работу нашего приложения с конкретными хранилищами данных. 
Эта изоляция от конкретного хранилища позволяет использовать разные базы данных в разных условиях. 
Например, при разработке и тестировании использовать что-то более легковесное,
а на релизном сервере применять рабочую базу данных.


Любая сущность, которая создается внутри приложения, называется моделью. Модели в Django лежат в директориях приложений 
в файлах models.py. Конкретный набор моделей зависит от приложения и может измениться со временем. Например,
в интернет-магазине могут быть такие сущности как:

* Раздел
* Обувь
* Верхняя одежда
* Штаны
* Товар

и так далее... В том же вайлдберизе или любом другом интернет магазине тысячи сущностей, которые связаны между собой

Связь между моделями и таблицами в базе данных: одна таблица — одна модель. В этом плане Django ORM не отходит далеко от
схемы базы данных. Всегда можно представить, как фактически представлены данные с точки зрения СУБД.
Что очень полезно, когда нужно что-то оптимизировать.

### Database Engine

К фактической базе данных Django подключается с помощью `Database Engines`. Одно приложение может подключаться к нескольким
базам данных. Это можно сделать и с помощью разных движков. Но такое случается нечасто. 
Обычно одна база приходится на одно веб-приложение.

Описываются базы данных в словаре `settings.DATABASES`:

    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
        }
    }

`ENGINE` указывает на конкретный движок
`NAME` в случае `SQLite` хранит имя файла. Для других СУБД это будет имя базы данных в удобном для
них формате

`default` — имя базы данных уже для самого Django
Когда используется несколько баз данных одновременно и имя другой не указано в коде явно,
эта «база данных по умолчанию» используется всегда.


### Описание моделей

Модели описываются в модулях `models.py`. Каждое приложение имеет свой собственный модуль `models.py`, в котором содержатся
описание моделей конкретного приложения.

Добавим в `<project_name>.<app_name>` следующий код:

    from django.db import models

    class User(models.Model):
        username = models.CharField(max_length=200) # никнейм пользователя
        firs_tname = models.CharField(max_length=200) # Имя
        la = models.TextField() # Фамилия
        email = models.EmailField(max_length=200)

User — это и есть наша первая модель. У нее четыре поля:

`username` — для хранения никнейма пользователя
`first_name` — для хранения имени пользователя
`last_name` — для хранения фамилии
`email` - электронная почта пользователя

В этом случае мы не описываем поле `id`, которое обычно является первичным ключом. 
В `models.Model` оно уже описано, и нам не нужно это делать дополнительно. Но мы его можем переопределить.

Со стороны Python всё готово. Но еще нужно сделать так, чтобы соответствующая таблица появилась в базе данных. Для 
этого необходимо сгенерировать миграцию.

### Миграции

Миграции меняют схему базы данных сообразно тому, как мы меняем модель. В Django работа с миграциями сделана на очень
высоком уровне. В том числе — на высоком уровне автоматизации.

Чтобы получить миграцию, выполняем команду:

`python manage.py makemigrations`

    Migrations for 'user':
    project_name/app_name/migrations/0001_initial.py
        - Create model User

Когда мы запускаем `makemigrations`, мы сообщаем Django, что внесли изменения в свои модели, например, 
создали новую модель. Также мы сообщаем о том, что хотим, чтобы эти изменения сохранились как миграция.

Миграции — это описания изменений в наших моделях, и в дальнейшем в схеме базы данных. Мы можем просмотреть эти файлы миграций. 
Они располагаются в директориях migrations внутри приложений. Например, в нашем случае файл миграции располагается в
project_name/app_name/migrations/0001_initial.py.


После того как файл с миграциями для нашей БД был сгенерирован, осталось только их применить, то есть внести изменения
непосредственно в нашу базу данных. Делается это с помощью похожей команды: `python manage.py migrate`

Созданная миграция была применена. Если все прошло успешно, то в базе данных появилась таблица user_user.

В первый раз Django применит приличное количество миграций, которые создают несколько вспомогательных таблиц. Они нужны
фреймворку для подсистемы работы с пользователями и прочих вещей, которые входят в обязательный минимум.
